package me.moomoo.anarchyexploitfixes.modules.chat.commandwhitelist;

import com.destroystokyo.paper.event.server.AsyncTabCompleteEvent;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import me.moomoo.anarchyexploitfixes.config.Config;
import me.moomoo.anarchyexploitfixes.utils.LogUtils;
import me.moomoo.anarchyexploitfixes.modules.AnarchyExploitFixesModule;
import org.bukkit.ChatColor;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerCommandPreprocessEvent;
import org.bukkit.event.server.TabCompleteEvent;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.logging.Level;

import static me.moomoo.anarchyexploitfixes.utils.CommandUtils.filteredSubCmdTabCompletions;
import static me.moomoo.anarchyexploitfixes.utils.CommandUtils.getCommandLabel;

public class CommandWhitelist implements AnarchyExploitFixesModule, Listener {

    private final HashSet<String> allowedCommands = new HashSet<>();
    private final HashSet<String> bannedSubCommands = new HashSet<>();
    private final boolean shouldUseProtocolLib;

    public CommandWhitelist() {
        shouldEnable();
        Config config = AnarchyExploitFixes.getConfiguration();

        config.addComment("chat.command-whitelist.enable", "This will make it pretty much impossible to find your plugins as only the commands you specify will be able to work." +
                "\nAllow bypass using permission: anarchyexploitfixes.commandwhitelistbypass" +
                "\nNOTE: Command tabcomplete suggestions after the '/' will still be sent to the client. There is sadly currently no method to filter these suggestions in 1.12." +
                "\n      If you're on 1.12+ and want to enable tab-completion, use CommandWhitelist: https://github.com/YouHaveTrouble/CommandWhitelist" +
                "\n      Otherwise set 'tab-complete' to -1 in spigot.yml."
        );

        this.shouldUseProtocolLib = config.getBoolean("chat.command-whitelist.use-protocollib", false, "Only enable if you have problems with plugins not properly registering commands.\nTHIS IS NOT A 'BETTER WAY TO DO IT'!");

        // Whitelisted Commands
        List<String> configuredAllowedCommands = config.getList("chat.command-whitelist.whitelisted-commands", Arrays.asList(
                "help", "vote", "kill", "discord", "togglechat", "toggleconnectionmsgs", "toggletells", "togglewhispering", "toggleprivatemsgs",
                "ignore", "ignorelist", "ignorehard", "toggledeathmsg", "dmt", "worldstats", "stats", "tps", "msg", "whisper", "w", "m", "t",
                "pm", "tell", "r", "reply", "last"
        ), "Add all commands you want your players to be able to access (without the '/'). Not case sensitive.");
        for (String configuredAllowedCmd : configuredAllowedCommands) {
            if (configuredAllowedCmd.startsWith("/")) { // Old configs had entries starting with "/"
                allowedCommands.add(configuredAllowedCmd.substring(1).toLowerCase());
            } else {
                allowedCommands.add(configuredAllowedCmd.toLowerCase());
            }
        }

        // Blacklisted Subcommands
        List<String> configuredBannedSubCommands = config.getList("chat.command-whitelist.blacklisted-subcommands", Arrays.asList(
                "help about", "vote List", "vote Best", "vote Total", "worldstats reload", "stats reload"
        ), "Add all subcommands you don't want your players to be able to access. Case sensitive!");
        bannedSubCommands.addAll(configuredBannedSubCommands);
    }

    @Override
    public String name() {
        return "command-whitelist";
    }

    @Override
    public String category() {
        return "command-whitelist";
    }

    @Override
    public void enable() {
        AnarchyExploitFixes plugin = AnarchyExploitFixes.getInstance();
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
        if (shouldUseProtocolLib) {
            if (AnarchyExploitFixes.getConfiguration().protocolLib_IsDisabled) {
                LogUtils.moduleLog(Level.WARNING, name(), "Can't enable packet listener because ProtocolLib is disabled in config.");
            } else {
                if (plugin.getServer().getPluginManager().isPluginEnabled("ProtocolLib")) {
                    new CWPacketListener(plugin, allowedCommands, bannedSubCommands);
                } else {
                    LogUtils.moduleLog(Level.SEVERE, name(), "Can't enable packet listener because ProtocolLib is missing.");
                }
            }
        }
    }

    @Override
    public boolean shouldEnable() {
        return AnarchyExploitFixes.getConfiguration().getBoolean("chat.command-whitelist.enable", false);
    }

    /*
    *     Credits go to YouHaveTrouble (https://github.com/YouHaveTrouble/CommandWhitelist)
    *     Code was mainly only implemented into AEF by xGinko.
    */

    @EventHandler(priority = EventPriority.HIGHEST)
    private void onCommandPreProcess(PlayerCommandPreprocessEvent event) {
        Player player = event.getPlayer();
        if (player.hasPermission("anarchyexploitfixes.commandwhitelistbypass")) return;

        String message = event.getMessage();
        String commandLabel = getCommandLabel(message).toLowerCase();
        String fullCommand = message.substring(commandLabel.length()+1);
        fullCommand = "/"+commandLabel+fullCommand;
        event.setMessage(fullCommand);

        if (!allowedCommands.contains(commandLabel)) {
            event.setCancelled(true);
            player.sendMessage(ChatColor.translateAlternateColorCodes('&',
                    AnarchyExploitFixes.getLang(player.getLocale()).command_Whitelist_BadCommand)
            );
            return;
        }

        for (String bannedSubCommand : bannedSubCommands) {
            if (message.toLowerCase().substring(1).startsWith(bannedSubCommand)) {
                event.setCancelled(true);
                player.sendMessage(ChatColor.translateAlternateColorCodes('&',
                        AnarchyExploitFixes.getLang(player.getLocale()).command_Whitelist_BadCommand)
                );
                return;
            }
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST)
    private void onAsyncCommandTabComplete(AsyncTabCompleteEvent event) {
        if (!(event.getSender() instanceof Player)) return;
        Player player = (Player) event.getSender();
        if (player.hasPermission("anarchyexploitfixes.commandwhitelistbypass")) return;

        String buffer = event.getBuffer();
        if (isSuspectedPluginScanPacket(buffer)) {
            event.setCancelled(true);
            return;
        }
        if (event.getCompletions().isEmpty()) return;

        event.setCompletions(
                filteredSubCmdTabCompletions(buffer, event.getCompletions(), bannedSubCommands)
        );
    }

    @EventHandler(priority = EventPriority.NORMAL)
    private void onCommandTabComplete(TabCompleteEvent event) {
        if (!(event.getSender() instanceof Player)) return;
        Player player = (Player) event.getSender();
        if (player.hasPermission("anarchyexploitfixes.commandwhitelistbypass")) return;

        String buffer = event.getBuffer();
        if (isSuspectedPluginScanPacket(buffer)) {
            event.setCancelled(true);
            return;
        }
        if (event.getCompletions().isEmpty()) return;

        event.setCompletions(
                filteredSubCmdTabCompletions(buffer, event.getCompletions(), bannedSubCommands)
        );
    }

    private static boolean isSuspectedPluginScanPacket(String buffer) {
        return (buffer.split(" ").length == 1 && !buffer.endsWith(" ")) || !buffer.startsWith("/");
    }
}
